# 14장 베스트 모델 만들기
## 1. 데이터의 확인과 실행
```python
df_pre = pd.read_csv.('', header=None)
df = df_pre.sample(frac = 1)
```
sample() : 정해진 비율만큼 랜덤으로 뽑아오는 함수 -> frac = 1 이라고 지정하면 100% 불러옴, 0.5는 50%\
한 줄당 모두 13개의 정보가 있다
```python
dataset = df.values
X = d ataset[: ,0:12]
Y = dataset[：,12]
```
딥러닝 실행
```python
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import ModelCheckpoint, EarlyStopping

import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

# seed 값 설정
seed = 0
np.random.seed(seed)
tf.random.set_seed(3)

# 데이터 입력
df_pre = pd.read_csv('', header = None)
df = df_pre.sample(frac = 1)
dataset = df.values
X = d ataset[: ,0:12]
Y = dataset[：,12]

# 모델 설정
model = Sequential()
model.add(Dense(30, input_dim = 12, activation = 'relu))
model.add(Dense(12, activation = 'relu'))
model.add(Dense(8, activation = 'relu'))
model.add(Dense(1, activation = 'sigmoid'))

# 모델 컴파일
model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])

# 모델 실행
model.fit(X, Y, epochs = 200, batch_size = 200)

# 결과 출력
print("\n Accuracy: %.4f" %(model.evaluate(X, Y)[1]))
```
## 2. 모델 업데이트하기
```python
import os

MODEL_DIR = './model/'
if not os.path.exists(MODEL_DIR):
    os.mkdir(MODEL_DIR)

modelpath = "./model/{epoch:02d}-{val_loss:.4f}.hdf5"
```
파일명 : {에포크}-{결과오차}.hdf5
```python
from keras.callbacks import ModelCheckpoint
```
-> 케라스의 콜백 함수중 ModelCheckpoint 불러오기
```python
checkpointer = ModelCheckpoint(filepath = modelpath, monitor = 'val_loss', verbose = 1)
```
모델 실행
```python
model.fit(X, Y, validation_split = 0.2, epochs = 200, batch_size = 200, verbose = 0, callbacks = [checkpointer])
```
모델 성능이 더 좋을 때만 저장
```python
checkpointer = ModelCheckpoint(filepath = modelpath, monitor='val_loss', verbose = 1, save_best_only = True)
```
## 3. 그래프로 확인하기
```python
df = df_pre.sample(frac = 0.15)

history = model.fit(X, Y, validation_split = 0.33, epochs = 3500, batch_size = 500)
```
그래프로 표현하기 위한 라이브러리
```python
import matplotlib.pyplot as plt

y_vloss = history.history['val_loss']
y_acc = history.history['acc']

x_len = np.arange(len(y_acc))
plt.plot(x_len, y_vloss, "o", c="red", markersize = 3)
plt.plot(x_len, y_acc, "o", c="blue", markersize = 3)
```
## 4. 학습의 자동 중단
과적합 때문에 중지..
```python
from keras.callbacks import EarlyStopping
```
EarlyStopping() : 오차가 줄지 않으면 학습을 멈춤
```python
early_stopping_callback = EarlyStopping(monitor = 'val_loss', patience = 100)

model.fit(X, Y, validation_split = 0.33, epochs = 2000, batch_size = 500, callbacks=[early_stopping_callback])
```
## 화인의 종류 예측하기 : 전체 코드
```python
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import ModelCheckpoint, EarlyStopping

import pandas as pd
import numpy as np
impot os
import tensorflow as tf

# seed 값 설정
np.random.seed(3)
tf.random.set_seed(3)

df_pre = pd.read_csv('', header = None)
df = df_pre.sample(frac = 0.15)
dataset = df.values
X = dataset:[:, 0:12]
Y = dataset[:, 12]

model = Sequential()
model.add(Dense(30, input_dim = 12, activation = 'relu))
model.add(Dense(12, activation = 'relu'))
model.add(Dense(8, activation = 'relu'))
model.add(Dense(1, activation = 'sigmoid'))

model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])

# 모델 저장 폴더 만들기
MODEL_DIR = './model/'
if not os.path.exists(MODEL_DIR):
    os.mkdir(MODEL_DIR)

modelpath = "". /model/{epoch：0 2 d }- {v al_lo ss: . 4 f } . hdf5"

# 모델 업데이트 및 저장
checkpointer = ModelCheckpoint(filepath = modelpath, monitor='val_loss', verbose = 1, save_best_only = True)

# 학습 자동 중단 설정
early_stopping_callback = EarlyStopping(monitor = 'val_loss', patience = 100)

model.fit(X, Y, validation_split = 0.33, epochs = 2000, batch_size = 500, callbacks=[early_stopping_callback])
```
