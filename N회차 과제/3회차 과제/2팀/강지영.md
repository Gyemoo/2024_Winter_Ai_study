# 10장
## 1. 모델의 정의

```
# 딥러닝을 구동하는 데 필요한 케라스 함수 호출
from tensorflow.keras.models import Sequential 
from tensorflow.keras.layers import Dense

# 필요한 라이브러리 불러옴 
import numpy as np 
import tensorflow as tf

# 실행할 때마다 같은 결과를 출력하기 위해 설정하는 부분 
np.random.seed(3)
tf.random.set_seed(3)

# 준비된 수술 환자 데이터를 불러옴
Data_set = np.loadtxt(". ./dataset/ThoraricSurgery.csv", delimiter=",")

# 환자의 기록과 수술 결과를 x와 노로 구분하여 저장 
X = Data_set[:,0:17]
Y = Data_set[：,17]

# 딥러닝 구조를 결정(모델을 설정하고 실행하는 부분) 
model = Sequential()
model.add(Dense(30, input_dim=17, activation='relu')) 
model.add(Dense(1, activation='sigmoid'))

# 딥러닝 실행
model. compile(loss = 'mean_squared_error', optimizer = 'adam',
metrics=['accuracy'])
model.fit(X, Y, epochs=100, batch_size=10)
```

+ model함수 선언: 딥러닝의 모델을 설정, 구동하는 부분
+ model = Sequential(): 딥러닝의 구조를 짜고 층을 설정
+ model. compile(): 위에서 정해진 모델을 컴퓨터가 알아들을 수 있게끔 컴파일
+ model.fit(): 모델을 실제로 수행

## 2. 입력층.은닉층,출력층
+ Sequential()함수 model로 선언->model.add()라인 추가->새로운 층 생성
+ 맨 마지막 층은 결과 출력하는 '출력층', 나머지는 '은닉층'
+ Dense함수 - (Dense(30, input_dim=17, activation='relu'))
     + 30: 이 층에 30층의 노드를 생성
     + input_dim: 입력 데이터에서 몇 개의 값을 가져올지 정함
     + 은닉층의 각 노드는 17개의 입력 값에서 임의의 가중치를 가지고 각 노드로 
전송되어 활성화 함수를 만남
     + activation: 원하는 활성화 함수를 적으면 됨

## 3. 모델 컴파일

```
model. compile(loss = 'mean_squared_error', optimizer = 'adam',
metrics=['accuracy'])
```
+ 모델이 효과적으로 구현될 수 있게 여러 가 
지 환경을 설정해 주면서 컴파일하는 부분
<img width="400" alt="image" src="https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128336150/3c2f84b5-47d8-4c76-9064-ffad7a6e1b6d">

+  metrics() 함수는 모델이 컴파일될 때 모델 수행 결과를 나타내게끔 
설정하는 부분

## 4. 교차 엔트로피
+ 교차 엔트로피 
는 주로 분류 문제에서 많이 사용되는데, 특별히 예측 값이 참과 거짓 둘 중 하나 
인 형식일 때는 binary_crosservtropy(이항 교차 엔트로피)를 씀
<img width="488" alt="image" src="https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128336150/7d4b470b-fa65-46c8-bf6a-451ecb62e176">


## 5. 모델 실행하기
model.fit(X, Y, epochs=100, batch_size=10)<br/>
+ 데이터를 불러 실행시킬 때 사용되는 함수
+  각 샘플이 처음 
부터 끝까지 100번 재사용될 때까지 실행을 반복하라는 뜻
+ batch_ 
size=10은 전체 470개의 샘플을 10개씩 끊어서 집어넣으라는 뜻

# 11장
## 1. 피마 인디언 데이터 분석하
+ 속성과 클래스를 먼저 구분
+ 모델 
의 정확도를 향상시키기 위해서는 데이터의 추가 및 재가공이 필요할 수 있음
+ 딤러닝의 구동에 앞서 데이터의 내용과 구조를 잘 파악하는 
것이 중요

## 2. pandas 를 활용한 데이터 조사

+ pandas를 사용해 데이터를 불러오기
+ read_CSv( ) 함수로 CSV 데이터 불러오기 - 
+ ```p rin t (d f.head(5))``` 데이터의 첫 디섯줄 불러오기


## 3. 데이터 가공하기, matplotlib을 이용해 그래프로 표현하기

```
print(df[['pregnant', 'class']], groupby(['pregnant.],as_ 
index=False),mean().sort_values(by='pregnant', ascending=True))
```

+  groupby () 함수를 사용해 pregnant 정보를 기준으로 하는 새 그룹 생성
+ as_ index=False는 pregnant 정보 옆에 새로운 인덱스를 생성

## 4. 피마 인디언의 당뇨병 예측 실행
<img width="227" alt="image" src="https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128336150/a48264ab-ed42-4c04-88de-2f9f605f988f">

```
from tensorflow. keras.models import Sequential
from tensorflow. keras. laye rs import Dense
import numpy
import tensorflow as tf

# seed 값 생성
numpy.random.seed(3)
tf.random.set_seed(3)

# 데이터 로드
dataset = numpy.loadtxt (". . /dataset/pim a-indians-diabetes. csv" ,
delimiter ="," )
X = dataset[：,0：8]
Y = dataset[:,8]

# 모델의 설정
model = Sequential( )
model.add(Dense(12, input_dim=8, activation = 'relu'))
model.add(Dense(8, activation = 'relu '))
model.add(Dense(1, activation = 'sigmoid'))

# 모델 컴파일
model. compile(loss= ,binary_crossentropy',
optimizer='adam, ,
metrics= [' accuracy' ] )

# 모델 실행
model.fit(X, Y, epochs=200, batch_size=10)
# 결과 출력
print("\n Accuracy： %.4f" % (model.evaluate(X, Y ) [1 ] ) )
```
