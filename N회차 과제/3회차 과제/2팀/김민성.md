## 10장
### 1. 모델의 정의
```python
# 딥러닝을 구동하는 데 필요한 케라스 함수 호출
from tensorflow.keras.models import Sequential 
from tensorflow.keras.layers import Dense

# 필요한 라이브러리 불러옴 
import numpy as np 
import tensorflow as tf

# 실행할 때마다 같은 결과를 출력하기 위해 설정하는 부분 
np.random.seed(3)
tf.random.set_seed(3)

# 준비된 수술 환자 데이터를 불러옴
Data_set = np.loadtxt(". ./dataset/ThoraricSurgery.csv", delimiter=",")

# 환자의 기록과 수술 결과를 x와 노로 구분하여 저장 
X = Data_set[:,0:17]
Y = Data_set[：,17]

# 딥러닝 구조를 결정(모델을 설정하고 실행하는 부분) 
model = Sequential()
model.add(Dense(30, input_dim=17, activation='relu')) 
model.add(Dense(1, activation='sigmoid'))

# 딥러닝 실행
model. compile(loss = 'mean_squared_error', optimizer = 'adam',
metrics=['accuracy'])
model.fit(X, Y, epochs=100, batch_size=10)
```
1. 딥러닝의 모델을 설정하고 구동하는 부분은 모두 model이라는 함수를 선언하며 시작이 됩니다.
2. model = Sequential() 로 시작되는 부분은 딥러닝의 구조를 짜고 층을 설정하는 부분입니다.
3. model.compile() 부분은 위에서 정해진 모델을 컴퓨터가 알아들을 수 있게끔 컴파일하는 부분입니다.
4. model.fit()으로 시작하는 부분은 모델을 실제로 수행하는 부분입니다.

### 2. 입력층, 은닉층, 출력층
```python
model = Sequential( )
model.add(Dense(30, input_dim=17, activation ='relu'))
model.add(Dense(1, activation='sigmoid'))
```
Sequential()함수를 model로 선언해 놓고 model.add()라는 라인을 추가하면 새로운 층이 만들어집니다. 맨 마지막 층은 결과를 출력하는 '출력층'이 되고, 나머 
지는 모두 ‘은닉층’의 역할을 합니다.
각각의 층은 Dense라는 함수를 통해 구체적으로 그 구조가 결정됩니다.<br/>
model.add(Dense(30, input_dim=17, activation ='relu'))를 분석해보겠습니다.
1. 30은 이 층에 30개의 노드를 만들겠다는 것입니다.
2. input_dim은 입력 데이터에서 몇 개의 값을 가져올지를 정하는 것입니다. 이 때 첫 번째 은닉층에 input_dim을 적어줌으로써 첫 번째 Dense가 은닉층 + 입력층의 역할을 겸합니다.
3.  activation부분에 우리가 원하는 활성화 함수를 적어 주면 됩니다.<br/><br/>

model.add(Dense(1, activation='sigmoid'))를 분석해보겠습니다.<br/>
-> 마지막 층이므로 이 층이 곧 출력층이 됩니다. 출력 값을 하나로 정해서 보여 줘야 하므로 출력층의 노드 수는 1개입니다. 그리고 이 노드에서 입력받은 
값 역시 활성화 함수를 거쳐 최종 출력 값으로 나와야 합니다. 여기서는 시그모이드(sigmoid)를 활성화 함수로 사용하였습니다.
![image](https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128350167/257932c8-db5a-4d9c-8d22-2545c4d2783e)


### 3. 모델 컴파일
```python
model.compile(loss = 'mean_squared_error', optimizer = 'adam',
metrics=['accuracy'])
```
model.compile부분은 앞서 지정한 모델이 효과적으로 구현될 수 있게 여러 가지 환경을 설정해 주면서 컴파일하는 부분입니다. metrics() 함수는 모델이 컴파일될 때 모델 수행 결과를 나타내게끔 
설정하는 부분입니다. <br/>
![image](https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128350167/6dd497e3-9d57-4aca-8877-5852e5faa2ee)<br/>
이는 최적화를 위한 방법입니다. 여기서 W는 각 층별 가중치(w)들의 집합을 말합니다.


### 4. 교차 엔트로피
교차 엔트로피는 주로 분류 문제에서 많이 사용되는데, 특별히 예측 값이 참과 거짓 둘 중 하나인 형식일 때는 binary_crosservtropy(이항 교차 엔트로피)를 씁니다.
현재 딥러닝과 관련하여 케라스에서 사용되는 대표적인 오차 함수는 다음과 같습니다. <br/>
![image](https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128350167/ef50aca4-4399-4946-bc51-5b0203b7f477)


### 5. 모델 실행하기
```python
model.fit(X, Y, epochs=100, batch_size=10)
```
컴파일 단계에서 정해진 환경을 주어진 데이터를 불러 실행시킬 때 사용되는 함수는 이와 같이 model.fit() 부분입니다.
1. 학습 프로세스가 모든 샘플에 대해 한 번 실행되는 것을 1 epoch라고 합니다. epochs=100은 각 샘플이 처음부터 끝까지 100번 재사용될 때까지 실행을 반복하라는 뜻입니다. 
2. bath_size는 샘플을 한 번에 몇 개씩 처리할지를 정하는 부분으로 batch_size=10은 전체 470개의 샘플을 10개씩 끊어서 집어넣으라는 뜻입니다.

## 11장
### 1. 딥러닝과 데이터
1. 데이터의 양보다 훨씬 중요한 것은, '필요한' 데이터가 얼마나 많은가입니다.
2. 좋은 데이터란 내가 알아내고자 하는 정보를 잘 담고 있는 데이터를 말합니다.
3. 내가 이루고 싶은 목적에 맞춰 가능한 한 많은 정보를 모았다면 이를 머신러닝과 딥러닝에서 사용할 수 있게 잘 정제된 데이터 형식으로 바꿔야 합니다.

### 2. 피마 인디언 데이터 분석하기
![image](https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128350167/8fb7ef8a-421c-4892-b3ad-84234f7cb3dc)
딥러닝을 구동하려면 반드시 속성과 클래스를 먼저 구분해야 합니다. 또한, 모델의 정확도를 향상시키기 위해서는 데이터의 추가 및 재가공이 필요할 수도 있습니다.
<br/> -> 따라서 딥러닝의 구동에 앞서 데이터의 내용과 구조를 잘 파악하는 것이 중요합니다.

### 3. pandas를 활용한 데이터 조사
1. 데이터를 다룰 때에는 데이터를 다루기 위해 만들어진 라이브러리를 사용하는 것이 좋습니다. 파이썬 데이터 관련 라이브러리 중 pandas를 사용해 데이터를 
불러올 수 있습니다.
2. 데이터의 내용을 간단히 확인할 때는 head() 함수를 활용합니다.
3. 데이터의 전반적인 정보를 확인하기 위해 df.info()를 출력합니다.
4. 정보별 특징을 좀 더 자세히 알고 싶으면 describe() 함수를 이용합니다.
5. 데이터의 일부 컬럼만 보고 싶을 때, 예를 들어 임신 횟수(pregnamt)와 당뇨병 발병 여부(class)만 확인해 보고 싶다면  print(df[['pregnant', 'class']])

### 4. 데이터 가공하기
``` python
print(df[['pregnant', 'class']], groupby(['pregnant.],as_ 
index=False),mean().sort_values(by='pregnant', ascending=True))
```
이는 groupby() 함수를 사용해 pregnant 정보를 기준으로 하는 새 그룹을 만들었습니다. as_index=False는 pregnant 정보 옆에 새로운 인덱스(index)를 만들 
어 줍니다. mean() 함수를 사용해 평균을 구하고 sort_values() 함수를 써서 pregnant 컬럼을 오름차순(ascending)으로 정리하게끔 설정합니다.

### 5. matplotlib를 이용해 그래프로 표현하기
```python
plt.figure(figsize(12,12))
```
그래프 크기를 결정합니다.

```python
sns.heatmap(df.corr(), linewidths=0.1, vmax=0.5, cmap=plt.cm.gist_heat, linecolor='white', annot=True)
```
heattnap( ) 함수는 두 항목씩 짝을 지은 뒤 각각 어떤 패턴으로 변화하는지를 관찰하는 함수입니다. 이를 통해서 그래프를 표시합니다.

```python
plt.show()
```
그래프를 표시합니다.


### 6. 피마 인디언의 당뇨병 예측 실행
![image](https://github.com/sejongsmarcle/2024_Winter_Ai_study/assets/128350167/320f2721-fd0e-4db6-835c-ce0013662470)
```python
from tensorflow. keras.models import Sequential
from tensorflow. keras. laye rs import Dense
import numpy
import tensorflow as tf

# seed 값 생성
numpy.random.seed(3)
tf.random.set_seed(3)

# 데이터 로드
dataset = numpy.loadtxt (". . /dataset/pim a-indians-diabetes. csv" ,
delimiter ="," )
X = dataset[：,0：8]
Y = dataset[:,8]

# 모델의 설정
model = Sequential( )
model.add(Dense(12, input_dim=8, activation = 'relu'))
model.add(Dense(8, activation = 'relu'))
model.add(Dense(1, activation = 'sigmoid'))

# 모델 컴파일
model. compile(loss='binary_crossentropy',
                optimizer='adam',
                metrics=['accuracy'])

# 모델 실행
model.fit(X, Y, epochs=200, batch_size=10)

# 결과 출력
print("\n Accuracy： %.4f" %(model.evaluate(X, Y)[1]))
```







