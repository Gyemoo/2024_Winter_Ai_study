# 12장 다중 분류 문제 해결하기
pairplot() 함수 : 데이터 전체를 한번에 보는 그래프 출력
```python
import seaborn as sns
import matplotlib.pyplot as plt

sns.pairplot(df, hue = 'species');
plt.show()
```
-> 이 그래프를 통해 프로그램 전략을 세울 수 있음
## 3. 원-핫 인코딩 : Y값을 0과 1로만 이루어진 형태로 바꿔 주는 기법
데이터 안에 문자열이 포함 -> numpy보다는 pandas로 데이터를 불러와 X, Y 값을 구분하는것이 좋음
```python
df = pd.read_csv('', names = ["sepal_length", "sepal_width", "petal_length", "petal_width", "species"])

dataset = df.values
X = dataset[:, 0:4].astype(float)
Y_obj = dataset[:,4]
```
Y 값이 문자열 -> 문자열을 숫자로 바꿔 주려면 클래스 이름을 숫자 형태로 바꿔 줘야함\
sklearn 라이브러리의 LabelEncoder()함수 사용
```python
from sklearn.preprocessing import LabelEncoder

e = LabelEncoder()
e.fit(Y_obj)
y = e.transform(Y_obj)
```
array(['Iris-setosa', 'Iris-versicolor', 'Iris-virginica]) -> array([1, 2, 3])\
또한 활성화 함수를 적용하려면 Y 값이 숫자 0과 1로 이루어져 있어야 한다.\
tf.keras.utils.categorical() 함수 사용
```python
from tensorflow.keras.utils import np_utils

Y_encoded = tf.keras.utils.to_categorical(Y)
```
array([1, 2, 3]) -> array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])
## 4. 소프트맥스
```python
model = Sequential()
model.add(Dense(16, input_dim = 4, activation = 'relu'))
model.add(Dense(3, activation = 'softmax))
```
소프트맥스는 총합이 1인 형태로 바꿔서 계산해 주는 함수이다.
## 품종 예측
```python
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.preprocessing import LabelEncoder

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf

# seed값 설정
np.random.seed(3)
tf.random.set_seed(3)

# 데이터 입력
df = pd.read_csv('', names = ["sepal_length", "sepal_width", "petal_length", "petal_width", "species"])

# 그래프 확인
sns.pairplot(df, hue = 'species');
plt.show()

# 데이터 분류
dataset = df.values
X = dataset[:, 0:4].astype(float)
Y_obj = dataset[:,4]

# 문자열을 숫자로 변환
e = LabelEncoder()
e.fit(Y_obj)
Y = e.transform(Y_obj)
Y_encoded = tf.keras.utils.to_categorical(Y)

# 모델의 설정
model = Sequential()
model.add(Dense(16, input_dim = 4, activation = 'relu'))
model.add(Dense(3, activation = 'softmax'))

# 모델 컴파일
model.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])

# 모델 실행
model.fit(X, Y_encoded, epochs = 50, batch_size = 1)

# 결과 출력
print("\n Accuracy: %.4f" %(model.evaluate(X, Y_encoded)[1]))
```
# 13장 과적합 피하기
과적합 : 학습 데이터셋 안에서는 일정 수준 이상의 예측 정확도를 보이지만, 새로운 데이터에 적용하면 잘 맞지 않는 것\
발생 이유 : 층이 너무 많음, 변수가 복잡, 테스트셋과 학습셋이 중복\
## 방지 방법
학습 데이터셋과 테스트 데이터셋을 완전히 구분한 다음 학습과 동시에 테스트를 병행하며 진행\
-> ex) 100개의 샘플중 70개는 학습셋 30개는 테스트\
학습이 깊어져서 학습셋 내부에서의 성공률은 높아져도 테스트셋에서는 효과가 없다면 과적합이 일어나는것\
불러온 X데이터와 Y데이터에서 각각 정해진 비율 만큼 구분하는 함수 -> sklearn 라이브러리의 train_test_split()함수
```python
from sklearn.model_selecton import train_test_split

# 학습셋과 테스트셋의 구분
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.3, random_state = seed)
```

## 모델 저장과 재사용
```python
from keras.models import load_model

# 모델 저장
model.save('')

# 모델 재사용
model = load_model('')
```
## k겹 교차 검증 : 데이터셋을 여러 개로 나누어 하나씩 테스트셋으로 사용하는 방법
sklearn의 StratifiedKFold() 함수
```python
from sklearn.model_selection import StratifiedKFold

# 10개로 쪼갬
n_fold = 10
skf = StratifiedKFold(n_splits = n_fold, shuffle = True, random_state = seed)
```
for 구문으로 n_fold 만큼 반봅
```python
for train, test in skf.split(X, Y):
    model = Sequential()
    model.add(Dense(24, input_dim = 60, activation = 'relu'))
    model.add(Dense(10, activation = ' relu'))
    model.add(Dense(1, activation = 'sigmoid'))
    model.compile(loss = 'mean_squared_error', optimizer = 'adam', metrics = ['accuracy'])
    model.fit(X[train], Y[train], epochs = 100, batch_size = 5)
```
정확도를 매번 저장하여 한 번에 보여주기
```python
accuracy = []

for train, test in skf.split(X, Y):
    k_accuracy = "%.4f" %(model.evaluate(X[test], Y[test])[1])accuracy.append(k_accuracy)

print("\n %.f fold accuracy:" % n_fold, accuracy)
```
